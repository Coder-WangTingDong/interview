# 基础知识

### 一、零散知识点

### 二、集合

#### Collection

#####  List

###### Vector(已废弃)

![image-20220217102444335](C:\Users\Administrator\Desktop\面试准备\vector.png)

```java
0. 底层数据结构是"数组"
1. 成员变量
    protected Object[] elementData;
	protected int elementCount;
	// 数组长度增加的变量值
	protected int capacityIncrement;
	// 默写虚拟机将header words也保存在数据中，所以-8
	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
2. 构造方法
    // 无参，默认长度为10
    public Vector() {
        this(10);
    }
	// 有参
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
3. 添加
    // 增加synchronized，保证线程安全，同时会降低效率
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
	// 扩容：新数组的扩容长度为原数组的两倍
	private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

```

###### ArrayList

![image-20220217102052215](C:\Users\Administrator\Desktop\面试准备\ArrayList.png)

```java
0. 底层数据结构是"数组"
1. 集合的成员变量
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    transient Object[] elementData;// 禁止该变量被序列化 
    private int size;
	protected transient int modCount = 0;
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
2. 构造方法
    // 无参构造方法，默认赋值为{},添加元素的默认长度则为10
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
	// 有参构造
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;// EMPTY_ELEMENTDATA={}
        } else {
            throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
        }
    }
3. 添加元素
    public boolean add(E e) {
    	// 确定集合中的数组
        ensureCapacityInternal(size + 1);
    	// 给对应的数组下标赋值，且size+1
        elementData[size++] = e;
        return true;
    }
    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
	// 计算数组容量
    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        // 如果集中的元素为空，集合长度取默认长度与传递值的最大值
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        // 集合中的元素不为空，则容量取传递值
        return minCapacity;
    }
	// 设置数组容量
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        // 如果传递的数组长度>集合现有长度，则扩容
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
	// 数组扩容
    private void grow(int minCapacity) { 
        int oldCapacity = elementData.length;
        // 新数组的长度为老数组长度的1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        // 如果扩容1.5倍后的长度 > 传递的数组长度，则使用传递的值
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        // 当新数组的长度 > Integer.MAX_VALUE - 8, 则扩容
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 将原数组的值赋值到新的数组中，并指向新的数组
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

###### LinkedList

![image-20220217105837260](C:\Users\Administrator\Desktop\面试准备\LinkedList.png)

```java
0. 底层数据结构是"双向链表"
1. 内部类(Node:保存节点信息)
    private static class Node<E> {
        E item;// value
        Node<E> next;// 前一个节点
        Node<E> prev;// 后一个节点
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
2. 成员变量
    transient int size = 0;
    transient Node<E> first;// 头节点
    transient Node<E> last;// 尾节点
3. 构造方法
    // 无参
    public LinkedList() {
    } 
	// 有参
    public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }
4. 添加
    public boolean add(E e) {
        linkLast(e);
        return true;
    }
	// 默认为尾插
    void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
	// 头插
    private void linkFirst(E e) {
        final Node<E> f = first;
        final Node<E> newNode = new Node<>(null, e, f);
        first = newNode;
        if (f == null)
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
    }

```

##### Set

###### HashSet

![image-20220218105848086](C:\Users\Administrator\Desktop\面试准备\HashSet.png)

```java
0. 底层结构"哈希表"
1. 成员变量
    private transient HashMap<E,Object> map;
    private static final Object PRESENT = new Object();
2. 构造函数
    public HashSet() {
        map = new HashMap<>();
    } 
    public HashSet(Collection<? extends E> c) {
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    } 
    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
    } 
    public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }
```



#### Map

###### Hashtable

###### HashMap

![image-20220218143210679](C:\Users\Administrator\Desktop\面试准备\HashMap.png)

```java
0. 底层结构"哈希表"
1. 内部类
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
2. 成员变量
    
```



### 三、多线程与并发

### 四、I\O、网络

### 五、设计模式

### 六、JVM

### 七、SQL

### 八、数据结构

### 哈希表(散列表、Hash表)

##### 问题

* Q1：Hash表的数组初始长度是多大

##### 概念

* **散列表**

  散列表用的是数组支持按照下标随机访问数据的特性，所以散列表是数组的一种扩展。

* **键|关键字**

  用作散列的值叫做"键"或"关键字"

* **散列函数(哈希函数、Hash函数)**

  把"键"或"关键字"转化为数组下标的映射方法叫做"散列函数"

* **散列值(哈希值、Hash值)**

  散列函数计算的值叫做"散列值"

* **散列冲突**

  由于不同的key对应的Hash(key)都不一样的散列函数几乎不可能，所以无法避免"散列冲突"。由于数组的存储空间有限，也会将加大散列冲突的概率。

##### 解决散列冲突的方法

* **开放寻址法**

  * 核心思想

    如果出现散列冲突，则重新探测一个空闲位置，将其插入。

    * 线性探测

      插入：插入数据时，如果某个数据经过散列函数散列后，位置已被占用，就从当前位置开始，向后查找，是否有空间位置，直到找到为止。

      查找：通过散列函数求出查找元素的键值对应的散列值，比较数组中下标为散列值的元素和要查找的元素，如果相等，则说明就是要找的元素，否则顺序往后查找。如果遍历到数组中的控线位置，还没有找到则说明查找的元素并没在散列表中。

      删除：根据查找规则，如果定位到空闲位置是被删除的元素，那么原来的查找算法失效，本来存在的数据会被认为不存在。(解决方法：将删除的元素特殊标记位deleted，当线性探测查找时，遇到标记位deleted的空间，不停，而是继续往下探测)

      问题：当散列表的数据越来越多，散列冲突的可能性增大，空闲位置越来越少，线性探测的时间会越来越长。

    * 二次探测

      线性探测每次步长是1，那它探测的下标序列是hash(key)+0，hash(key)+1，hash(key)+2...

      二次探测的步长是原来的"二次方"，探测的下标序列是hash(key)+0，hash(key)+1^2，hash(key)+2^2...

    * 双重散列

    * 

      

      

      

      

      

      

      

    

* **链表法**

# WEB服务

### SpringCloud

#### Zuul

#### Eureka

#### Feign

#### Ribbon

### Spring

### Mybatis

### 分布式事务

# 中间件

### Redis

#### 分布式锁

###### 情景1：单体服务，定义全局变量，作为标志位进行判断，比如true则添加数据，false修改数据；

### ElasticSearch

### RabbitMQ

# 处理的问题

* 情景：接收外呼结果，由于上游系统的并发发送，导致系统数据重复，影响统计结果

  处理方式：使用队列、分布式锁